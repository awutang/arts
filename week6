1.Algorithm
  Unique Binary Search Trees  二叉排序树的数目
  采用了动态规划的思想
  https://leetcode.com/problems/unique-binary-search-trees/submissions/

2.review
  This Morning Routine will Save You 20+ Hours Per Week
  1.当你不去工作而用于做其他事时，你会想到关于工作的有创造性的想法。所以工作的时候投入工作，不工作时就好好休息。
  2.早上的三个小时适合做需要思考、复杂的事情。my opinion:早上效率高

3.tip
  统计日志中哪些类的日志打印了，适用于统计合作方调用接口的场景（如果合作方没有调用业务类，则说明合作方已经不调用接口了）
  每行按空格或TAB分割，输出日志文件中的5项（从1开始计），并排序，分组统计唯一
  cat xxx.log | awk  '{print $5}' | sort |uniq。

4.Share
  https://www.programcreek.com/2011/07/java-equals-and-hashcode-contract/
  问题引入:当向HashMap中存放key与value时，如何确定当前插入的key与之前的重复了？
  因为现在是想将数据放入hashMap中，我们从存储结构进行分析（涉及到hashCode()与equal()的协同约定）因为HashMap内部实现是哈希表（array和linkedList），
存储时用key的hashCode值作为索引去存储到array中，如果碰撞了就放到LinkedList中（jdk1.8优化超过8个转换成红黑树），所以判断key即对象是否相等时，先查找，
先用key的hashCode值一次就可以定位到具体的bucket（O(1)）,然后再遍历LinkedList,比较equal(),equal()相等则认为两个key相等。所以如果你对某个对象只是
覆盖了equal(),由于hashCode()不相等，也是认为是两个不同的对象即不同的key。
  从存储结构即本质进行分析就很透彻了。ps:哈希表的好处是提高存储查找效率，O(1)就可以定位到具体的bucket。
