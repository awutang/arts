
#### Algorithm
  - 
  
#### review
  -  https://www.wsj.com/video/china/0607633C-BC93-4382-BE47-CC6946249913.html
  -  这个视频讲述了为啥在美国大选中，为啥fracking水力压裂油气开采法一直被提及，原因是因为水力压裂油气开采法是摇摆州宾夕法尼亚州的民生所在，因为这个为当地的居民提供了很多工作，川普是支持这个方法的，
  但是拜登虽然不会禁止此开采法但是会限制其中的一项最新开采技术，所以川普用这个事项争取宾夕法尼亚居民的选票，但是宾夕法尼亚的匹茨堡的公司主要是科技类的，如果科技公司的员工想在此定居，肯定是关注这周边
  的环境与气候的，而开采天然气会破坏环境，所以这类人是支持拜登的。
  
#### tip
  -  类中的成员对象如果是Enum,更改Enum不会影响序列化与反序列化；但是如果成员对象是一个普通类则这个类一定得加上serialId.
  
#### Share
  - https://www.cnblogs.com/qianguyihao/p/4744233.html
    1. 标记-清除算法：标记+清除 未打标记的会被回收
        1. What:第一次扫描标记出从根可达的对象，第二次扫描回收不可达对象
            1. 标记阶段利用了：根搜索算法、可达性分析、Gc roots
                1. Gc算法中的gc root可达性分析是利用局部变量表中的引用来的，分析某一对象是否引用了其他对象（其他对象被引用）
            2. 如果在可达性分析过程中又产生新的对象引用，这肯定会使得可达性结果不一致，因此也需要stop the world
        2. Disadvantage:如果对象很多（与堆内存和对象数量成正比）则需要大量的标记与清除，效率很低；回收后会产生大量的不连续的内存碎片，如果需要分配一个大对象则很难找到连续的内存空间，则容易触发第二次gc.
            1. 因此不适合作为在新生代中的回收算法，从而引出标记-复制算法。
    2. 标记-复制算法：为了解决效率问题，复制算法可以一次性清除不可用空间从而提高效率；也不会产生不连续内存碎片
        1. What:内存空间分为两块。标记出可达对象；将可达对象复制到另一块空间并将之前空间中的所有对象
        2. disadvantage：可用空间缩小了；如果需要复制的对象很多，那也很浪费时间，因此不适用老年代这种存活对象很多的场景（引出标记-整理算法），比较适合新生代。
    3. 标记-整理算法：不会将可用空间缩小、也不会将所有的对象都进行复制
        1. What:标记可达对象；整理：可达对象向一端移动按照内存地址次序依次排列；将末端内存地址以后的内存全部回收
            1. 整理（内存+数据整理），在移动过程中如果应用仍旧使用对象，那肯定是有问题的，因为对象的地址都变化了，所以需要stop the world
            2. 如何解决数据移动后旧的引用仍生效的问题？因为移动过程中某个对象的实际物理地址是发生了改变的。难道是利用中间变量？--我觉得可以（引用变量就是中间变量），只要将新的地址维护到保存着对象实际地址的地方就行，jvm应该是将引用类型变量的值进行了修改,但代码中仍然使用旧的引用变量。
        2. disadvantage：需要将存活对象的地址更新到引用变量的值中（对象引用重定向），因此效率会比标记-复制低。
    4. 分代收集理论：
        1. What:将内存按照对象存活周期分为不同的几块，现在是分为了新生代和老年代。
            1. 新生代中对象朝生夕死，存活对象少，选择标记-复制算法
            2. 老年代中每次gc后都会存活大量对象，没有额外空间用于复制过去，因此不能选择标记-复制，可以选择标记-清除或标记-整理
  
