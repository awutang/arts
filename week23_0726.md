
#### Algorithm
  - 
  

#### review
  - https://www.youtube.com/watch?v=OClXTdFyoVw
  - 这是我看的John fish的youtube视频，可以练习听力和语感。视频中他讲了几个如何成功度过学习时光的几个点，虽然有一些是只适用于在校的，但是其中几个点也适用于现在工作后的学习，特别是有一个特别好的理念是
  做计划安排工作学习不是为了隔离开一段完全被约束的时间段，而是为了在工作学习上花费更少的时间，将必须要做的事情做了之后才能够做其他想做的事情（比如自己放松、朋友聚会等）所以将这段时间做规划，重点是在于能够获得更多的时间
  而不是将时间进行分段。
    我觉得这一点值得借鉴，做计划安排是为了让自己更有效率从而可以节省出更多其他的时间，比如去放松等，但是这些学习工作虽然是需要做的事情，但是你这么想它是必须要做的事情时候可能会无形之中给自己
压力，所以我认为形成习惯就好，而且弄懂知识的快乐也是一种我想要的快乐。  
  
#### tip
  1.ReentrantLock中的锁是用CAS实现的，AQS中的state字段;当state值为0说明没有其他线程获取锁，则CAS设置为1并且将独占线程字段设置为当前线程；如果不为0则需要校验独占锁的线程是否为当前线程，若是则重入（将state加1）
  
#### Share
  - https://hesey.wang/2011/04/introduction-to-java-virtual-machine.html
  - 看看耗子叔对Java virtual machine的一个概念性入门讲解。
  - what：本文旨在给所有希望了解JVM（Java Virtual Machine）的同学一个概念性的入门，主要介绍了JVM的组成部分以及它们内部工作的机制和原理。当然本文只是一个简单的入门，不会涉及过多繁杂的参数和配置，感兴趣的同学可以做更深入的研究。
  - how:JVM本身是一个规范，所以可以有多种实现，除了Hotspot外，还有诸如Oracle的JRockit、IBM的J9也都是非常有名的JVM.
  1. 构成：
    1. classLoader+runtime data area+execution engine+native interface
        1. runtime data area：
            1. Thread specifc:java stack+native method stack+program counter register
                1. Java stack：由栈帧组成，一个帧对应一个方法调用，调用方法时压入栈帧，方法返回时弹出栈帧并抛弃。Java栈的主要任务是存储方法参数、局部变量、中间运算结果，并且提供部分其它模块工作需要的数据。前面已经提到Java栈是线程私有的，这就保证了线程安全性。
                    1. 一个栈帧包括：
                        1. 局部变量区：以字长为单位的数组，在这里，byte、short、char类型会被转换成int类型存储，除了long和double类型占两个字长以外，其余类型都只占用一个字长。特别地，boolean类型在编译时会被转换成int或byte类型，boolean数组会被当做byte类型数组来处理。局部变量区也会包含对象的引用，包括类引用、接口引用以及数组引用。
                            1. 字长？这个字长从编程语言的角度理解就没意义了。字长要从汇编语言的角度理解，就是指令集里面的运算和内存操作时操作数的长度。比如你写一条load a, reg1，那么a这个操作数的长度就是字长。32位机的字长最大是32bit，64位机的字长最大是64bit。
                            2. 实例方法隐含第一个局部变量this，它指向调用该方法的对象引用
                        2. 操作数栈：也是以字长为单位的数组，但只能进行入栈出栈的基本操作。在进行计算时，操作数被弹出栈，计算完毕后再入栈。
                        3. 帧数据区 
                    2. 局部变量区和操作数栈的大小依照具体方法在编译时就已经确定。调用方法时会从method area中找到对应类的类型信息，从中得到具体方法的局部变量区和操作数栈的大小，依此分配栈帧内存，压入Java栈。
                2. Native method stack:类似于Java栈，主要存储了本地方法调用的状态。在Sun JDK中，本地方法栈和Java栈是同一个。
                3. 
            1. Thread common:method area+heap
                1. Method area:类型信息和类的静态变量都存储在方法区中。类的所有信息都存储在方法区.
                    1. 由于方法区是所有线程共享的，所以必须保证线程安全，举例来说，如果两个类同时要加载一个尚未被加载的类，那么一个类会请求它的ClassLoader去加载需要的类，另一个类只能等待而不会重复加载。
                    2. 为了加快调用方法的速度，通常还会为每个非抽象类创建私有的方法表，方法表是一个数组，存放了实例可能被调用的实例方法的直接引用。方法表对于多态有非常重要的意义。为啥？
                    3. 在Sun JDK中，方法区对应了持久代（Permanent Generation）—jdk1.7之后将持久代移到了方发区中
                2. Heap:堆用于存储对象实例以及数组值。堆中有指向类数据的指针，该指针指向了方法区中对应的类型信息。堆中还可能存放了指向方法表的指针。堆是所有线程共享的，所以在进行实例化对象等操作时，需要解决同步问题。此外，堆中的实例数据中还包含了对象锁，并且针对不同的垃圾收集策略，可能存放了引用计数或清扫标记等数据。
                    1. 新生代 new generation 
                        1. 大多数情况下新对象都被分配在新生代中，新生代由Eden Space和两块相同大小的Survivor Space组成，后两者主要用于Minor GC时的对象复制（Minor GC的过程在此不详细讨论）。
                        2. JVM在Eden Space中会开辟一小块独立的TLAB（Thread Local Allocation Buffer）区域用于更高效的内存分配，我们知道在堆上分配内存需要锁定整个堆，而在TLAB上则不需要，JVM在分配对象时会尽量在TLAB上分配，以提高效率。
                    1. 旧生代 old generation，与永久代即持久代区别?—持久代中存放类信息，与GC无关。新生代中存活时间较久的对象将会被转入旧生代，旧生代进行垃圾收集的频率没有新生代高。
                        1. JVM根据对象存活周期不同，把堆内存划分为年轻代、老年代、持久代。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。年轻代和年老代的划分是对垃圾收集影响比较大的。https://juejin.im/post/5ec54920e51d45789d64b62c
                        2. 持久代JDK1.8后变成元空间，元空间不再占用堆中的空间。而持久代却是在堆中开辟空间，用于存放静态文件、类信息等，一般不做GC。
        1. classLoader:
            1. What:将编译好的class文件从硬盘装入内存
            2. Why:jvm可以实例化或者以其他方式使用class文件，支持运行时动态加载？具体指啥，应用运行时才生成实体，多态？
            3. How:
                1. 分类：BootStrap  Class Loader + Extension+System+User Defined
                2. 过程：
                    1. 装载：将class文件加载到jvm，VM内部就以“类的全限定名+ClassLoader实例ID”来标明类。
                        1. ClassLoader实例和加载的类的实例在heap,两者的类信息位于method area
                        2. 双亲委派模型：当一个ClassLoader要加载类时，它会先请求它的双亲ClassLoader，而它的双亲ClassLoader会继续把加载请求提交再上一级的ClassLoader，直到启动这个可用的类加载器
                            1. 安全加载：依赖了类加载器隔离的原理：不同类加载器加载的类之间是无法直接交互的，即使是同一个类，被不同的ClassLoader加载，它们也无法感知到彼此的存在。这样即使有恶意的类冒充自己在核心包（例如java.lang）下，由于它无法被启动类加载器加载，也造成不了危害
                    2. 链接：把二进制的类型信息合并到JVM运行时状态中去。二进制？如何合并到运行时状态中？
                        1. 包括：验证、准备、解析
                    3. 初始化：初始化类中的静态变量，并执行类中的static代码、构造函数。所以其实classLoader并没有创建一个实例—是的
        1. execution engine:执行方式主要分为解释执行、编译执行、自适应优化执行、硬件芯片执行方式。JVM的指令集是基于栈而非寄存器的，这样做的好处在于可以使指令尽可能紧凑，便于快速地在网络上传输（别忘了Java最初就是为网络设计的），同时也很容易适应通用寄存器较少的平台，并且有利于代码优化，由于Java栈和PC寄存器是线程私有的，线程之间无法互相干涉彼此的栈。每个线程拥有独立的JVM执行引擎实例。
            1. JVM指令由单字节操作码和若干操作数组成。对于需要操作数的指令，通常是先把操作数压入操作数栈，即使是对局部变量赋值，也会先入栈再赋值。
            2. 解释执行：和一些动态语言类似，JVM可以解释执行字节码 动态语言到底指啥，有啥特殊性？
            3. 编译执行：为了提升执行速度，Sun JDK提供了将字节码编译为机器指令的支持，主要利用了JIT（Just-In-Time）编译器在运行时进行编译，它会在第一次执行时编译字节码为机器码并缓存，之后就可以重复利用。
            4. 自适应优化：思想是程序中10%~20%的代码占据了80%~90%的执行时间，所以通过将那少部分代码编译为优化过的机器码就可以大大提升执行效率。自适应优化的典型代表是Sun的Hotspot VM，正如其名，JVM会监测代码的执行情况，当判断特定方法是瓶颈或热点时，将会启动一个后台线程，把该方法的字节码编译为极度优化的、静态链接的C++代码。当方法不再是热区时，则会取消编译过的代码，重新进行解释执行。
                1. 对内联代码等优化也起到了很大的作用。由于面向对象的多态性，一个方法可能对应了很多种不同实现，自适应优化就可以通过监测只内联那些用到的代码，大大减少了内联函数的大小
            5. 执行引擎也必须保证线程安全性，因而JMM（Java Memory Model）也是由执行引擎确保的。
        2. JNI:java native interface我认为是hotspot C++实现的方法，right?为啥程序中使用了native interface之后会使得应用不再具有跨平台特性呢？难道是因为不同的jvm实现中有的并没有实现某一种应用中需要用到的native interface？
 
  
  
